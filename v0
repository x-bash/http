# shellcheck shell=bash

# author:       Li Junhao           edwin.jh.lee@gmail.com    edwinjhlee.github.io
# maintainer:   Li Junhao

# @src std/dict  # @src std/oo # std/dict -> std/list -> std/oo
xrc std/dict

############################
# Section 1: Instantiation & Utilities
# Section 2: Dict & Path
# Section 3: Header
# Section 4: QueryString & Body
# Section 5: Request & Response
# Section 6: CRUD -- post get put delete
############################

############################
# Section 1: Instantiation & Utilities
############################
# http_new(){  oo.create_new_function http "$@";  }

http_make(){
    dict_make "${1:?Provide name}"
    local O="$1"
    dict_put url "${2:?Provide url}"
}

debug_init http

http_browse(){
    local BROWSER=${BROWSER:-$BROWSER}
    local website=${1:?Provide websites}
    if [ -n "$BROWSER" ]; then
        $BROWSER "$website"
    elif uname -a | grep -q Darwin; then
        open -a "/Applications/Safari.app" "$website"
    elif command -v xdg-open > /dev/null; then
        xdg-open "$website"
    elif command -v gnome-open > /dev/null; then
        gnome-open "$website"
    else
        echo "Could not detect the web browser to use."
        return 1
    fi
}

############################
# Section 2: Dict & Path
############################
httpdict_pgetput(){
    local O="${O:?Provide Object name}"
    case $# in
        1) httpdict_pget "$1";;
        2) httpdict_pput "$1" "$2";;
        *) echo "More than 2 variable provided" >&1; return 2;
    esac
}

httpdict_pget(){
    local O="${O:?Provide Object name}"
    dict_get "${1:?Provide dict key}"
}

httpdict_pput(){
    local O="${O:?Provide Object name}"
    dict_put "${1:?Provide dict key}" "${2:?Provide dict value}" 
}

http_cd(){
    [ -z "$O" ] && return 1
    local URL=${URL:-$(httpdict_pget "url")}
    dict_put "url" "$URL/${1:?Provide url}"
}

http_path(){   # TODO: how to cd back
    local url
    url="$(httpdict_pget url)"
    if [ -z "$url" ]; then
        echo "$1"
    else
        echo "$url$1" # TODO: it is ugly... Isn't it?
    fi
}

############################
# Section 3: Header
############################

: <<'DOCTEST'
> http_make git https://api.git.com
> O=git http_qs token token123
> O=git http_header content-type application/json
> O=git http_header accept application/json
> O=git http_header
content-type: application/json
accept: application/json
DOCTEST
http_header(){
    case $# in
        0) http_header_dump ;;
        1) http_header_get "$1" ;;
        2) http_header_put "$1" "$2" ;;
    esac
}


http_header_put(){ 
    dict_put "header" "${1:?header key}" "${2:?value}"; 
}

http_header_mput(){
    for i in "$@"; do
        if [[ "$i" = *=* ]]; then
            http_header_put "${i%=*}" "${i##*=}"
        else
            http_header_put "$i"
        fi
    done
}

http_header_get(){ 
    : "${O:?Provide http object name}"
    dict_get "header" "${1:?header key}"; 
}

http_header_remove(){ dict_drop header "${1:?header key}"; }

http_header_dump(){
    : "${O:?Provide http object name}"
    dict_scope header | ITEM_SEP="\n" KV_SEP=": " dict_pprint
}

_http_header_dump_curl_args(){
    http_header_dump | while read -r line; do
        printf "-H \"%s\" " "$line"
    done
}

# http_header(){
#     echo "$(http_header_dump)
# $HEADER
# "
# }


# TODO: Introducing file with multiple candidates
HTTP_HEADER_CONTENT_TYPE_LSIT="
application/json
application/text
application/xml
application/yml
application/json;charset=utf-8
"

http_header_content_type(){
    if [ $# -eq 0 ]; then
        if http_header_get "Content-Type"; then
            return 0
        else
            printf "Candiates are as below: \n%s" "$HTTP_HEADER_CONTENT_TYPE_LSIT"
            return 1
        fi
    fi

    # TODO: Introducing file with multiple candidates
    local i
    local IFS="
"
    local target="${1:?Content-Type candidates like application/json}"

    for i in $HTTP_HEADER_CONTENT_TYPE_LSIT; do
        if str_regex "$i" "$target"; then
            http_debug "Add header: Content-Type=$i"
            http_header_put "Content-Type" "$i"
            return 0
        fi
    done
    http_debug "Add header: Content-Type=$target"
    http_header_put "Content-Type" "$target"
}

alias http.header.content-type.eq.json+utf8='http_header_content_type_eq "application/json;charset=utf-8";'

http_header_referer(){
    http_header_put "Referer" "${1:?Referer}"
}

http_header_agent(){
    http_header_put "User-Agent" "${1:?User agent}"
}

############################
# Section 4: QueryString & Body
############################
# Notice: http_qs_put will put the empty value

: <<'DOCTEST'
> http_make git https://api.git.com
> O=git http_qs token token123
> O=git http_header_put content-type application/json
> O=git http_header_put accept application/json
> O=git http_qs_dump_json
{
  "token": "token123"
}
DOCTEST
http_qs(){
    case $# in
        0) http_qs_dump ;;
        1) http_qs_get "$1" ;;
        2) http_qs_put "$1" "$2" ;;
    esac
}

http_qs_put(){
    : "${O:?Provide http object name}"
    dict_put qs "${1:?header key}" "${2:-${!1}}"
}

# Notice 1: `http_qs_put abc=``  will put the entry { abc: "" }
# Notice 2: `abc=; http_qs_put abc` will NOT put any entry
http_qs_mput(){
    local value
    for i in "$@"; do
        if [[ "$i" = *=* ]]; then
            http_qs_put "${i%=*}" "${i##*=}"
        else
            eval value="\"\$${i}\""
            [ -n "$value" ] && http_qs_put "$i" "$value"
        fi
    done;
}

http_qs_get(){
    : "${O:?Provide http object name}"
    dict_get qs "${1:?header key}"
}

http_qs_remove(){ dict_drop qs "${1:?header key}"; }
http_qs_dump_json(){
    [ -z "$O" ] && return 1
    # dict_scope qs
    dict_scope qs | dict_pjson
}

_http_qs_dump_curl(){
    [ -z "$O" ] && return 1
    local line

    printf "-G "
    dict_scope qs | KV_SEP="=" dict_print | while read -r line; do
        printf "--data-urlencode \"%s\" " "$line"
    done
}

: <<'DOCTEST'
> http_make git https://api.git.com
> O=git http_body token token123
> O=git http_header_put content-type application/json
> O=git http_header_put accept application/json
> O=git http_body_dump_json
{
  "token": "token123"
}
DOCTEST

http_body(){
    case $# in
        0) http_body_dump_json ;;
        1) http_body_get "$1" ;;
        2) http_body_put "$1" "$2" ;;
    esac
}

# Just in case.
http_body_put(){
    local value="${2:-${!1}}"
    dict_put body "${1:?header key}" "$value"
    # [ -n "$value" ] && dict_put "body.${1:?header key}" "$value"
}

# Redis like naming
http_body_mput(){
    local value
    for i in "$@"; do
        if [[ "$i" = *=* ]]; then
            http_body_put "${i%=*}" "${i##*=}"
        else
            value="${!i}"
            [ -n "$value" ] && http_body_put "$i" "$value"
        fi
    done;
}

http_body_remove(){ dict_drop body "${1:?header key}"; }
http_body_dump_json(){
    [ -z "$O" ] && return 1
    dict_scope body | dict_pjson
}

############################
# Section 5: Request & Response
############################
http_resp_header_all(){
    cat "$(_http_resp_latest_header_filepath)"
}

http_resp_header(){
    local filepath
    filepath="$(_http_resp_latest_header_filepath)"
    local filter=${1:?provide filter} A
    A="$(grep "$filter:" "$filepath")"
    A="${A##$filter: }"
    echo -n "${A%"${A##*[![:space:]]}"}"
}

http_resp_body(){
    cat "$(_http_resp_latest_body_filepath)"
}

_http_resp_latest_header_filepath(){
    echo "${TMPDIR}x-cmd-x-bash-std-http-header.${O:?Please provide O}"
}

_http_resp_latest_body_filepath(){
    echo "${TMPDIR}x-cmd-x-bash-std-http-body.${O:?Please provide O}"
}

_http_request(){
    local IFS=$' '
    local O="${O:?Please provide O}"

    local X=${X:-get)} data=${2:-"$D"} path
    path="$(http_path "$1")"

    if [ -z "$data" ]; then
        data="$(http_body_dump_json "")"
    fi

    local tmp
    tmp=$(mktemp)
    echo "$data" > "$tmp"
    # TODO: Display the data if only if body is text and data is NOT a lot
    # http_debug "body is: $data"
    # [ -n "$DEBUG" ] && echo "body is: $data" >&2

    local header_filepath data_filepath
    header_filepath="$(_http_resp_latest_header_filepath)"
    data_filepath="$(_http_resp_latest_body_filepath)"

    if [ "$X" = GET ] || [ "$X" = DELETE ] || [ "$X" = HEAD ]; then
        http_debug curl -D "$header_filepath" -X "$X" "$(_http_qs_dump_curl)" "$(_http_header_dump_curl_args)" "$path"
        eval curl -D "$header_filepath"  -X "$X" "$(_http_qs_dump_curl)" "$(_http_header_dump_curl_args)" "$path" 1>"$data_filepath" 2>/dev/null #2>(http_debug)
    else
        http_debug curl -D "$header_filepath" -X "$X" "$(_http_header_dump_curl_args)" -d "@$tmp" "$path"
        eval curl -D "$header_filepath" -X "$X" "$(_http_header_dump_curl_args)" -d "@$tmp" "$path" 1>"$data_filepath" 2>/dev/null #2>(http_debug)
    fi
    rm "$tmp"

    http_debug "Response Header is: $(cat "$header_filepath")"

    local a b c
    # shellcheck disable=SC2034
    read -r a b c <<<"$(cat "$header_filepath")"
    
    if [ -n "$b" ] && [ "$b" -ge 200 ] && [ "$b" -le 299 ]; then
        cat "$data_filepath"
        return 0
    fi

    printf "HttpCode is %s, Code is 1\n" "$b" >&2
    return 1
}

_http_request_json_body() (  # Notice: Using subshell
    url=$1;  shift
    http_body_mput "$@"
    _http_request "$url" "$(http_body_dump_json "")"
)

############################
# Section 6: CRUD -- post get put delete
############################

# crud
http_post(){ X=POST _http_request "$@"; }
http_post_json(){ X=POST _http_request_json_body "$@"; }
# TODO
http_post_form(){ X=POST _http_request_json_body "$@"; }
http_post_text(){ X=POST _http_request_json_body "$@"; }
http_post_bin(){ X=POST _http_request_json_body "$@"; }

http_get() (    # Notice: Using subshell
    url=$1;  shift
    http_qs_mput "$@"
    X=GET _http_request "$url"
)

http_put(){ X=PUT _http_request "$@"; }
http_put_json(){ X=PUT _http_request_json_body "$@"; }
# TODO
http_put_form(){ X=PUT _http_request_json_body "$@"; }
http_put_text(){ X=PUT _http_request_json_body "$@"; }
http_put_bin(){ X=PUT _http_request_json_body "$@"; }

http_delete(){ X=DELETE _http_request "$@"; }

http_head(){ X=HEAD _http_request "$@"; }
